---
import BaseLayout from '../layouts/Base.astro';
import { getEntry } from 'astro:content';

const pwaSettings = await getEntry('pwaSettings', 'index');

const meta = {
  title: 'My Page',
  description: 'Customize your personal page',
};
---

<BaseLayout meta={meta}>
  <div class="user-page">
    <div class="background-overlay"></div>
    
    <!-- Sticky Notes Container (Top Left) -->
    <div id="sticky-notes-container" class="sticky-notes-container"></div>
    
    <div class="page-header">
      <h1 id="page-title" contenteditable="true" spellcheck="false">My Page</h1>
      <p id="page-subtitle" class="subtitle" contenteditable="true" spellcheck="false">Your personal workspace</p>
    </div>

    <!-- Control Bar -->
    <div class="control-bar">
      <button id="view-all-btn" class="btn-control-bar" title="View All Notes">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="7" height="7"></rect>
          <rect x="14" y="3" width="7" height="7"></rect>
          <rect x="3" y="14" width="7" height="7"></rect>
          <rect x="14" y="14" width="7" height="7"></rect>
        </svg>
      </button>
      <input type="text" id="search-notes" class="search-input" placeholder="Search notes...">
      <select id="sort-notes" class="sort-select">
        <option value="date">Sort by Date</option>
        <option value="images">Has Images</option>
        <option value="text">Text Only</option>
      </select>
      <button id="clear-notes-btn" class="btn-control-bar btn-danger" title="Delete All Notes">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 6h18M8 6V4h8v2M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6"></path>
        </svg>
      </button>
    </div>

    <!-- Notes Sidebar -->
    <div id="notes-sidebar" class="notes-sidebar">
      <div id="collapsed-notes"></div>
    </div>

    <!-- Control Buttons -->
    <div class="note-controls">
      <button id="add-note-btn" class="btn-control btn-add">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>
      </button>
    </div>

    <!-- Expanded Notes Container -->
    <div id="notes-container"></div>

    <!-- View All Panel (Hidden by default) -->
    <div id="view-all-panel" class="view-all-panel" style="display: none;">
      <div class="view-all-header">
        <h2>All Notes</h2>
        <button id="close-view-all-btn" class="btn-close-panel">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div id="view-all-content" class="view-all-content"></div>
    </div>
  </div>
</BaseLayout>

<script>
  interface StickyNote {
    id: string;
    title: string;
    content: string;
    color: string;
    collapsed: boolean;
    sticky: boolean;
    createdAt: number;
  }

  // IndexedDB Helper
  class NotesDB {
    private dbName = 'StickyNotesDB';
    private storeName = 'notes';
    private db: IDBDatabase | null = null;
    private useIndexedDB = true;

    constructor() {
      // Check if IndexedDB is available
      if (!window.indexedDB) {
        console.warn('IndexedDB not available, will use localStorage fallback');
        this.useIndexedDB = false;
      }
    }

    async init(): Promise<void> {
      if (!this.useIndexedDB) {
        console.log('Using localStorage fallback');
        return Promise.resolve();
      }

      return new Promise((resolve, reject) => {
        try {
          const request = indexedDB.open(this.dbName, 1);

          request.onerror = () => {
            console.error('IndexedDB open error:', request.error);
            this.useIndexedDB = false;
            this.db = null;
            console.log('Falling back to localStorage');
            resolve();
          };
          
          request.onsuccess = () => {
            this.db = request.result;
            
            // Verify the object store exists
            if (!this.db.objectStoreNames.contains(this.storeName)) {
              console.error('Object store not found, reinitializing database');
              this.db.close();
              this.db = null;
              
              // Delete and recreate the database
              const deleteRequest = indexedDB.deleteDatabase(this.dbName);
              deleteRequest.onsuccess = () => {
                console.log('Database deleted, recreating...');
                // Reinitialize
                this.init().then(resolve).catch(() => {
                  this.useIndexedDB = false;
                  resolve();
                });
              };
              deleteRequest.onerror = () => {
                console.error('Failed to delete database, using localStorage');
                this.useIndexedDB = false;
                resolve();
              };
            } else {
              console.log('IndexedDB opened successfully with object store:', this.storeName);
              resolve();
            }
          };

          request.onupgradeneeded = (event) => {
            const db = (event.target as IDBOpenDBRequest).result;
            console.log('Database upgrade needed, creating object store');
            if (!db.objectStoreNames.contains(this.storeName)) {
              db.createObjectStore(this.storeName, { keyPath: 'id' });
              console.log('Object store created:', this.storeName);
            }
          };
        } catch (error) {
          console.error('IndexedDB exception:', error);
          this.useIndexedDB = false;
          console.log('Falling back to localStorage');
          resolve();
        }
      });
    }

    async getAllNotes(): Promise<StickyNote[]> {
      if (!this.useIndexedDB) {
        // Use localStorage fallback
        const stored = localStorage.getItem('stickyNotes');
        return stored ? JSON.parse(stored) : [];
      }

      if (!this.db) await this.init();
      
      if (!this.useIndexedDB) {
        const stored = localStorage.getItem('stickyNotes');
        return stored ? JSON.parse(stored) : [];
      }

      return new Promise((resolve, reject) => {
        const transaction = this.db!.transaction([this.storeName], 'readonly');
        const store = transaction.objectStore(this.storeName);
        const request = store.getAll();

        request.onsuccess = () => resolve(request.result || []);
        request.onerror = () => reject(request.error);
      });
    }

    async saveNote(note: StickyNote): Promise<void> {
      if (!this.useIndexedDB) {
        // Use localStorage fallback
        const stored = localStorage.getItem('stickyNotes');
        const notes: StickyNote[] = stored ? JSON.parse(stored) : [];
        const index = notes.findIndex(n => n.id === note.id);
        if (index >= 0) {
          notes[index] = note;
        } else {
          notes.push(note);
        }
        localStorage.setItem('stickyNotes', JSON.stringify(notes));
        console.log('Note saved to localStorage:', note.id);
        return Promise.resolve();
      }

      if (!this.db) {
        console.log('DB not initialized, initializing now...');
        await this.init();
      }

      if (!this.useIndexedDB) {
        // Fallback after init attempt failed
        const stored = localStorage.getItem('stickyNotes');
        const notes: StickyNote[] = stored ? JSON.parse(stored) : [];
        const index = notes.findIndex(n => n.id === note.id);
        if (index >= 0) {
          notes[index] = note;
        } else {
          notes.push(note);
        }
        localStorage.setItem('stickyNotes', JSON.stringify(notes));
        console.log('Note saved to localStorage (after failed IndexedDB):', note.id);
        return Promise.resolve();
      }

      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db!.transaction([this.storeName], 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.put(note);

          request.onsuccess = () => {
            console.log('Note saved to IndexedDB successfully:', note.id);
            resolve();
          };
          request.onerror = () => {
            console.error('IndexedDB save error:', request.error);
            reject(request.error);
          };
          transaction.onerror = () => {
            console.error('Transaction error:', transaction.error);
            reject(transaction.error);
          };
        } catch (err) {
          console.error('Exception in saveNote:', err);
          reject(err);
        }
      });
    }

    async deleteNote(id: string): Promise<void> {
      if (!this.useIndexedDB) {
        const stored = localStorage.getItem('stickyNotes');
        const notes: StickyNote[] = stored ? JSON.parse(stored) : [];
        const filtered = notes.filter(n => n.id !== id);
        localStorage.setItem('stickyNotes', JSON.stringify(filtered));
        return Promise.resolve();
      }

      if (!this.db) await this.init();

      if (!this.useIndexedDB) {
        const stored = localStorage.getItem('stickyNotes');
        const notes: StickyNote[] = stored ? JSON.parse(stored) : [];
        const filtered = notes.filter(n => n.id !== id);
        localStorage.setItem('stickyNotes', JSON.stringify(filtered));
        return Promise.resolve();
      }

      return new Promise((resolve, reject) => {
        const transaction = this.db!.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.delete(id);

        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    async clearAllNotes(): Promise<void> {
      if (!this.useIndexedDB) {
        localStorage.removeItem('stickyNotes');
        return Promise.resolve();
      }

      if (!this.db) await this.init();

      if (!this.useIndexedDB) {
        localStorage.removeItem('stickyNotes');
        return Promise.resolve();
      }

      return new Promise((resolve, reject) => {
        const transaction = this.db!.transaction([this.storeName], 'readwrite');
        const store = transaction.objectStore(this.storeName);
        const request = store.clear();

        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }
  }

  class StickyNotesManager {
    private notes: StickyNote[] = [];
    private notesContainer: HTMLElement | null;
    private collapsedContainer: HTMLElement | null;
    private activeNoteId: string | null = null;
    private db: NotesDB;

    private colors = [
      '#fef08a', // yellow
      '#fca5a5', // red
      '#bfdbfe', // blue
      '#bbf7d0', // green
      '#e9d5ff', // purple
      '#fed7aa', // orange
    ];

    constructor() {
      this.notesContainer = document.getElementById('notes-container');
      this.collapsedContainer = document.getElementById('collapsed-notes');
      this.db = new NotesDB();
      this.initialize();
    }

    async initialize() {
      try {
        console.log('Initializing StickyNotesManager...');
        await this.db.init();
        console.log('DB initialized');
        await this.migrateFromLocalStorage();
        console.log('Migration complete');
        await this.loadNotes();
        console.log('Notes loaded:', this.notes.length);
        this.setupEventListeners();
        this.renderAllNotes();
        console.log('StickyNotesManager initialized successfully');
      } catch (error) {
        console.error('Failed to initialize StickyNotesManager:', error);
        alert('Failed to initialize notes system. Please refresh the page.');
      }
    }

    async migrateFromLocalStorage() {
      const oldNotes = localStorage.getItem('stickyNotes');
      if (oldNotes) {
        try {
          const notes = JSON.parse(oldNotes);
          console.log('Migrating', notes.length, 'notes from localStorage to IndexedDB...');
          
          for (const note of notes) {
            await this.db.saveNote(note);
          }
          
          // Keep a backup in localStorage for now
          localStorage.setItem('stickyNotes_backup', oldNotes);
          localStorage.removeItem('stickyNotes');
          console.log('Migration complete!');
        } catch (error) {
          console.error('Migration error:', error);
        }
      }
    }

    setupEventListeners() {
      const addBtn = document.getElementById('add-note-btn');
      addBtn?.addEventListener('click', () => this.createNote());

      const clearBtn = document.getElementById('clear-notes-btn');
      clearBtn?.addEventListener('click', () => this.clearAllNotes());

      const viewAllBtn = document.getElementById('view-all-btn');
      viewAllBtn?.addEventListener('click', () => this.showViewAllPanel());

      const closeViewAllBtn = document.getElementById('close-view-all-btn');
      closeViewAllBtn?.addEventListener('click', () => this.hideViewAllPanel());

      const searchInput = document.getElementById('search-notes') as HTMLInputElement;
      searchInput?.addEventListener('input', (e) => this.handleSearch((e.target as HTMLInputElement).value));

      const sortSelect = document.getElementById('sort-notes') as HTMLSelectElement;
      sortSelect?.addEventListener('change', (e) => this.handleSort((e.target as HTMLSelectElement).value));
    }

    async loadNotes() {
      try {
        this.notes = await this.db.getAllNotes();
        // Ensure all notes have required properties
        this.notes = this.notes.map((note: any) => ({
          ...note,
          collapsed: note.collapsed !== undefined ? note.collapsed : true,
          sticky: note.sticky !== undefined ? note.sticky : false,
          createdAt: note.createdAt || Date.now(),
        }));
      } catch (error) {
        console.error('Error loading notes:', error);
        this.notes = [];
      }
    }

    async saveNote(note: StickyNote) {
      try {
        console.log('Attempting to save note:', note.id, note.title);
        await this.db.saveNote(note);
        console.log('Note saved successfully');
      } catch (error) {
        console.error('Error saving note:', error);
        const errorMsg = error instanceof Error ? error.message : String(error);
        alert(`Failed to save note: ${errorMsg}. Check console for details.`);
        throw error;
      }
    }

    async createNote() {
      const randomColor = this.colors[Math.floor(Math.random() * this.colors.length)];
      const noteNumber = this.notes.length + 1;
      const note: StickyNote = {
        id: Date.now().toString(),
        title: `Note ${noteNumber}`,
        content: '',
        color: randomColor,
        collapsed: false,
        sticky: false,
        createdAt: Date.now(),
      };

      this.notes.push(note);
      await this.saveNote(note);
      this.renderExpandedNote(note);
      this.activeNoteId = note.id;
      
      // Auto-focus the title for easy editing
      setTimeout(() => {
        const noteEl = this.notesContainer?.querySelector(`[data-id="${note.id}"]`);
        const titleInput = noteEl?.querySelector('input');
        titleInput?.select();
      }, 100);
    }

    renderAllNotes() {
      this.notes.forEach(note => {
        if (note.collapsed) {
          this.renderCollapsedNote(note);
        } else {
          this.renderExpandedNote(note);
          this.activeNoteId = note.id;
        }
      });
      this.renderStickyNotes();
    }

    renderCollapsedNote(note: StickyNote) {
      if (!this.collapsedContainer) return;

      const tab = document.createElement('div');
      tab.className = 'collapsed-note-tab';
      tab.dataset.id = note.id;
      tab.style.cssText = `background-color: ${note.color}; cursor: pointer; padding: 0.75rem; margin-bottom: 0.5rem; border-radius: 8px 0 0 8px; box-shadow: -2px 2px 4px rgba(0,0,0,0.2); transition: all 0.2s; width: 150px; max-width: 150px;`;
      tab.innerHTML = `<div style="font-weight: 600; color: #333; font-size: 0.9rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${this.escapeHtml(note.title)}</div>`;
      
      tab.addEventListener('click', () => this.expandNote(note.id));
      tab.addEventListener('mouseenter', () => {
        tab.style.transform = 'translateX(-5px)';
      });
      tab.addEventListener('mouseleave', () => {
        tab.style.transform = 'translateX(0)';
      });

      this.collapsedContainer.prepend(tab);
    }

    renderExpandedNote(note: StickyNote) {
      if (!this.notesContainer) return;

      const noteEl = document.createElement('div');
      noteEl.className = 'sticky-note-expanded';
      noteEl.dataset.id = note.id;
      noteEl.style.cssText = `
        background-color: ${note.color};
        position: fixed;
        width: 400px;
        max-width: 90vw;
        min-height: 300px;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        z-index: 350;
      `;
      
      // Create header
      const header = document.createElement('div');
      header.style.cssText = 'display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem 0.5rem; border-bottom: 2px solid rgba(0, 0, 0, 0.15); flex-shrink: 0;';
      
      // Create title input
      const titleInput = document.createElement('input');
      titleInput.type = 'text';
      titleInput.value = note.title;
      titleInput.placeholder = 'Title';
      titleInput.style.cssText = 'flex: 1; min-width: 0; border: none; background: transparent; font-size: 1rem; font-weight: 600; color: #333; outline: none; padding: 0.25rem; cursor: text; pointer-events: auto;';
      titleInput.setAttribute('tabindex', '0');
      
      // Create image upload button (for mobile)
      const imageBtn = document.createElement('button');
      imageBtn.innerHTML = 'ðŸ–¼ï¸';
      imageBtn.title = 'Add image';
      imageBtn.setAttribute('type', 'button');
      imageBtn.style.cssText = 'width: 36px; height: 36px; min-width: 36px; border: none; background: rgba(0, 0, 0, 0.1); border-radius: 6px; cursor: pointer; font-size: 1.1rem; flex-shrink: 0; display: flex; align-items: center; justify-content: center; padding: 0; pointer-events: auto;';
      
      // Create hidden file input
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      fileInput.style.display = 'none';
      
      // Create sticky/pin button
      const stickyBtn = document.createElement('button');
      stickyBtn.innerHTML = note.sticky ? 'ðŸ“Œ' : 'ðŸ“';
      stickyBtn.title = note.sticky ? 'Unpin note' : 'Pin note';
      stickyBtn.setAttribute('type', 'button');
      stickyBtn.style.cssText = 'width: 36px; height: 36px; min-width: 36px; border: none; background: rgba(0, 0, 0, 0.1); border-radius: 6px; cursor: pointer; font-size: 1.1rem; flex-shrink: 0; display: flex; align-items: center; justify-content: center; padding: 0; pointer-events: auto;';
      
      // Create minimize button
      const minimizeBtn = document.createElement('button');
      minimizeBtn.innerHTML = 'âˆ’';
      minimizeBtn.setAttribute('type', 'button');
      minimizeBtn.style.cssText = 'width: 36px; height: 36px; min-width: 36px; border: none; background: rgba(0, 0, 0, 0.1); border-radius: 6px; cursor: pointer; font-size: 1.5rem; color: #333; flex-shrink: 0; display: flex; align-items: center; justify-content: center; padding: 0; pointer-events: auto;';
      
      // Create delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.innerHTML = 'Ã—';
      deleteBtn.setAttribute('type', 'button');
      deleteBtn.style.cssText = 'width: 36px; height: 36px; min-width: 36px; border: none; background: rgba(0, 0, 0, 0.1); border-radius: 6px; cursor: pointer; font-size: 1.5rem; color: #333; flex-shrink: 0; display: flex; align-items: center; justify-content: center; padding: 0; pointer-events: auto;';
      
      // Create content area with contenteditable div for rich content
      const contentArea = document.createElement('div');
      contentArea.contentEditable = 'true';
      contentArea.innerHTML = this.renderContent(note.content);
      contentArea.setAttribute('data-placeholder', 'Write your note... (paste images with Ctrl/Cmd+V)');
      contentArea.style.cssText = 'flex: 1; border: none; background: transparent; padding: 1rem; font-size: 1rem; color: #333; outline: none; cursor: text; line-height: 1.5; width: 100%; box-sizing: border-box; font-family: inherit; pointer-events: auto; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;';
      contentArea.setAttribute('tabindex', '0');
      
      // Add placeholder styling
      const style = document.createElement('style');
      style.textContent = `
        [contenteditable][data-placeholder]:empty:before {
          content: attr(data-placeholder);
          color: #999;
          pointer-events: none;
        }
        [contenteditable] img {
          max-width: 100%;
          height: auto;
          border-radius: 4px;
          margin: 0.5rem 0;
          display: block;
        }
      `;
      document.head.appendChild(style);
      
      // Handle image paste
      contentArea.addEventListener('paste', async (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;

        let hasImage = false;
        
        // Check all clipboard items
        for (let i = 0; i < items.length; i++) {
          const item = items[i];
          
          // Check if it's an image type
          if (item.type.indexOf('image') !== -1) {
            e.preventDefault();
            hasImage = true;
            
            try {
              const blob = item.getAsFile();
              if (!blob) {
                console.log('No blob from getAsFile, trying alternative method');
                continue;
              }

              // Check image size (max 1MB for pasted images)
              if (blob.size > 1024 * 1024) {
                alert('Pasted image is too large. Please use images under 1MB.');
                return;
              }

              const reader = new FileReader();
              reader.onload = (event) => {
                const imageData = event.target?.result as string;
                
                // Create and insert image element
                const img = document.createElement('img');
                img.src = imageData;
                img.style.cssText = 'max-width: 100%; height: auto; border-radius: 4px; margin: 0.5rem 0; display: block;';
                
                // Insert at cursor position or append
                const selection = window.getSelection();
                if (selection && selection.rangeCount > 0) {
                  const range = selection.getRangeAt(0);
                  range.deleteContents();
                  range.insertNode(img);
                  
                  // Add a line break after the image
                  const br = document.createElement('br');
                  range.setStartAfter(img);
                  range.insertNode(br);
                  
                  // Move cursor after the break
                  range.setStartAfter(br);
                  range.setEndAfter(br);
                  selection.removeAllRanges();
                  selection.addRange(range);
                } else {
                  contentArea.appendChild(img);
                  contentArea.appendChild(document.createElement('br'));
                }
                
                // Update note content
                this.updateNoteContent(note.id, contentArea.innerHTML);
              };
              
              reader.onerror = (error) => {
                console.error('Error reading image:', error);
                alert('Failed to paste image. Please try again.');
              };
              
              reader.readAsDataURL(blob);
              return; // Exit after processing image
            } catch (error) {
              console.error('Error pasting image:', error);
              alert('Failed to paste image. Please try the upload button instead.');
              return;
            }
          }
        }
      });
      
      // Assemble the note
      header.appendChild(titleInput);
      header.appendChild(imageBtn);
      header.appendChild(stickyBtn);
      header.appendChild(minimizeBtn);
      header.appendChild(deleteBtn);
      noteEl.appendChild(header);
      noteEl.appendChild(contentArea);
      noteEl.appendChild(fileInput);

      // Event handlers
      titleInput.addEventListener('input', (e) => {
        const target = e.target as HTMLInputElement;
        this.updateNoteTitle(note.id, target.value);
      });

      contentArea.addEventListener('input', () => {
        this.updateNoteContent(note.id, contentArea.innerHTML);
      });

      // Image upload handler
      imageBtn.addEventListener('click', () => {
        fileInput.click();
      });
      imageBtn.addEventListener('mouseenter', () => {
        imageBtn.style.background = 'rgba(0, 0, 0, 0.2)';
      });
      imageBtn.addEventListener('mouseleave', () => {
        imageBtn.style.background = 'rgba(0, 0, 0, 0.1)';
      });

      fileInput.addEventListener('change', async (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (!file) return;

        if (file.size > 1024 * 1024) {
          alert('Image is too large. Please use images under 1MB.');
          return;
        }

        const reader = new FileReader();
        reader.onload = (event) => {
          const imageData = event.target?.result as string;
          
          const img = document.createElement('img');
          img.src = imageData;
          img.style.cssText = 'max-width: 100%; height: auto; border-radius: 4px; margin: 0.5rem 0; display: block;';
          
          contentArea.appendChild(img);
          this.updateNoteContent(note.id, contentArea.innerHTML);
        };
        reader.readAsDataURL(file);
        fileInput.value = '';
      });

      stickyBtn.addEventListener('click', () => this.toggleSticky(note.id));
      stickyBtn.addEventListener('mouseenter', () => {
        stickyBtn.style.background = 'rgba(0, 0, 0, 0.2)';
      });
      stickyBtn.addEventListener('mouseleave', () => {
        stickyBtn.style.background = 'rgba(0, 0, 0, 0.1)';
      });

      minimizeBtn.addEventListener('click', () => this.collapseNote(note.id));
      minimizeBtn.addEventListener('mouseenter', () => {
        minimizeBtn.style.background = 'rgba(0, 0, 0, 0.2)';
      });
      minimizeBtn.addEventListener('mouseleave', () => {
        minimizeBtn.style.background = 'rgba(0, 0, 0, 0.1)';
      });

      deleteBtn.addEventListener('click', () => {
        if (confirm(`Delete "${note.title}"? This cannot be undone.`)) {
          this.deleteNote(note.id);
        }
      });
      deleteBtn.addEventListener('mouseenter', () => {
        deleteBtn.style.background = 'rgba(255, 0, 0, 0.3)';
        deleteBtn.style.color = '#fff';
      });
      deleteBtn.addEventListener('mouseleave', () => {
        deleteBtn.style.background = 'rgba(0, 0, 0, 0.1)';
        deleteBtn.style.color = '#333';
      });

      this.notesContainer.appendChild(noteEl);
    }

    async expandNote(id: string) {
      // Collapse currently active note if any
      if (this.activeNoteId && this.activeNoteId !== id) {
        await this.collapseNote(this.activeNoteId);
      }

      const note = this.notes.find(n => n.id === id);
      if (!note) return;

      note.collapsed = false;
      await this.saveNote(note);

      // Remove from collapsed view
      const tab = this.collapsedContainer?.querySelector(`[data-id="${id}"]`);
      tab?.remove();

      // Remove existing expanded view if present
      const existingExpanded = this.notesContainer?.querySelector(`[data-id="${id}"]`);
      existingExpanded?.remove();

      // Render expanded
      this.renderExpandedNote(note);
      this.activeNoteId = id;
    }

    async collapseNote(id: string) {
      const note = this.notes.find(n => n.id === id);
      if (!note) return;

      note.collapsed = true;
      await this.saveNote(note);

      // Remove from expanded view
      const noteEl = this.notesContainer?.querySelector(`[data-id="${id}"]`);
      noteEl?.remove();

      // Render collapsed
      this.renderCollapsedNote(note);

      if (this.activeNoteId === id) {
        this.activeNoteId = null;
      }
    }

    async updateNoteTitle(id: string, title: string) {
      const note = this.notes.find(n => n.id === id);
      if (note) {
        note.title = title;
        await this.saveNote(note);
        
        // Update collapsed tab if it exists
        const tab = this.collapsedContainer?.querySelector(`[data-id="${id}"] div`);
        if (tab) {
          tab.textContent = title;
        }
      }
    }

    async updateNoteContent(id: string, content: string) {
      const note = this.notes.find(n => n.id === id);
      if (note) {
        note.content = content;
        await this.saveNote(note);
      }
    }

    async deleteNote(id: string) {
      this.notes = this.notes.filter(n => n.id !== id);
      await this.db.deleteNote(id);
      
      const noteEl = this.notesContainer?.querySelector(`[data-id="${id}"]`);
      noteEl?.remove();
      
      const tab = this.collapsedContainer?.querySelector(`[data-id="${id}"]`);
      tab?.remove();

      if (this.activeNoteId === id) {
        this.activeNoteId = null;
      }

      // Re-render sticky notes to remove deleted note if it was pinned
      this.renderStickyNotes();
    }

    async clearAllNotes() {
      if (confirm('Delete all notes? This cannot be undone.')) {
        this.notes = [];
        await this.db.clearAllNotes();
        if (this.notesContainer) {
          this.notesContainer.innerHTML = '';
        }
        if (this.collapsedContainer) {
          this.collapsedContainer.innerHTML = '';
        }
        this.activeNoteId = null;
        this.renderStickyNotes();
      }
    }

    async toggleSticky(id: string) {
      const note = this.notes.find(n => n.id === id);
      if (!note) return;

      note.sticky = !note.sticky;
      await this.saveNote(note);
      
      // Update the sticky button in the expanded note
      const noteEl = this.notesContainer?.querySelector(`[data-id="${id}"]`);
      const stickyBtn = noteEl?.querySelector('button[title*="Pin"]') as HTMLButtonElement;
      if (stickyBtn) {
        stickyBtn.innerHTML = note.sticky ? 'ðŸ“Œ' : 'ðŸ“';
        stickyBtn.title = note.sticky ? 'Unpin note' : 'Pin note';
      }
      
      this.renderStickyNotes();
    }

    renderStickyNotes() {
      const stickyContainer = document.getElementById('sticky-notes-container');
      if (!stickyContainer) return;

      stickyContainer.innerHTML = '';
      const stickyNotes = this.notes.filter(n => n.sticky).sort((a, b) => a.createdAt - b.createdAt);

      stickyNotes.forEach((note, index) => {
        const stickyNote = document.createElement('div');
        stickyNote.className = 'sticky-note-card';
        stickyNote.dataset.id = note.id;
        stickyNote.style.cssText = `
          background-color: ${note.color};
          cursor: pointer;
          width: 200px;
          min-height: 120px;
          padding: 1rem;
          border-radius: 8px;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
          transition: transform 0.2s;
        `;

        const title = document.createElement('div');
        title.style.cssText = 'font-weight: 600; color: #333; font-size: 0.95rem; margin-bottom: 0.5rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
        title.textContent = note.title;

        const content = document.createElement('div');
        content.style.cssText = 'color: #555; font-size: 0.85rem; line-height: 1.4; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = note.content;
        content.textContent = tempDiv.textContent || '';

        stickyNote.appendChild(title);
        stickyNote.appendChild(content);

        // Add thumbnail if note has an image
        if (note.content.includes('<img')) {
          const imgMatch = note.content.match(/<img[^>]+src="([^"]+)"/);
          if (imgMatch) {
            const thumbnail = document.createElement('img');
            thumbnail.src = imgMatch[1];
            thumbnail.style.cssText = 'width: 100%; height: 60px; object-fit: cover; border-radius: 4px; margin-top: 0.5rem;';
            stickyNote.appendChild(thumbnail);
          }
        }

        stickyNote.addEventListener('click', async (e) => {
          e.preventDefault();
          e.stopPropagation();
          console.log('Sticky note clicked:', note.id);
          await this.expandNote(note.id);
        });
        stickyNote.addEventListener('mouseenter', () => {
          stickyNote.style.transform = 'translateY(-4px)';
        });
        stickyNote.addEventListener('mouseleave', () => {
          stickyNote.style.transform = 'translateY(0)';
        });

        stickyContainer.appendChild(stickyNote);
      });
    }

    showViewAllPanel() {
      const panel = document.getElementById('view-all-panel');
      const content = document.getElementById('view-all-content');
      if (!panel || !content) return;

      content.innerHTML = '';
      
      this.notes.sort((a, b) => b.createdAt - a.createdAt).forEach(note => {
        const noteCard = document.createElement('div');
        noteCard.className = 'view-all-note-card';
        noteCard.style.cssText = `
          background-color: ${note.color};
          padding: 1rem;
          border-radius: 8px;
          margin-bottom: 1rem;
          cursor: pointer;
          transition: transform 0.2s;
        `;

        const title = document.createElement('div');
        title.style.cssText = 'font-weight: 600; color: #333; font-size: 1rem; margin-bottom: 0.5rem;';
        title.textContent = note.title + (note.sticky ? ' ðŸ“Œ' : '');

        const contentDiv = document.createElement('div');
        contentDiv.style.cssText = 'color: #555; font-size: 0.9rem; line-height: 1.5;';
        contentDiv.innerHTML = note.content;

        noteCard.appendChild(title);
        noteCard.appendChild(contentDiv);

        noteCard.addEventListener('click', () => {
          this.hideViewAllPanel();
          this.expandNote(note.id);
        });
        noteCard.addEventListener('mouseenter', () => {
          noteCard.style.transform = 'translateX(4px)';
        });
        noteCard.addEventListener('mouseleave', () => {
          noteCard.style.transform = 'translateX(0)';
        });

        content.appendChild(noteCard);
      });

      panel.style.display = 'flex';
    }

    hideViewAllPanel() {
      const panel = document.getElementById('view-all-panel');
      if (panel) {
        panel.style.display = 'none';
      }
    }

    handleSearch(query: string) {
      const lowerQuery = query.toLowerCase().trim();
      
      if (!lowerQuery) {
        this.renderStickyNotes();
        return;
      }

      const stickyContainer = document.getElementById('sticky-notes-container');
      if (!stickyContainer) return;

      stickyContainer.innerHTML = '';
      const filteredNotes = this.notes.filter(note => 
        note.title.toLowerCase().includes(lowerQuery) || 
        note.content.toLowerCase().includes(lowerQuery)
      );

      if (filteredNotes.length === 0) {
        const noResults = document.createElement('div');
        noResults.style.cssText = 'color: white; padding: 1rem; text-align: center;';
        noResults.textContent = 'No notes found';
        stickyContainer.appendChild(noResults);
        return;
      }

      filteredNotes.forEach(note => {
        const noteCard = document.createElement('div');
        noteCard.className = 'sticky-note-card';
        noteCard.dataset.id = note.id;
        noteCard.style.cssText = `
          background-color: ${note.color};
          cursor: pointer;
          width: 200px;
          min-height: 120px;
          padding: 1rem;
          border-radius: 8px;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
          transition: transform 0.2s;
          margin-bottom: 1rem;
        `;

        const title = document.createElement('div');
        title.style.cssText = 'font-weight: 600; color: #333; font-size: 0.95rem; margin-bottom: 0.5rem;';
        title.textContent = note.title;

        const content = document.createElement('div');
        content.style.cssText = 'color: #555; font-size: 0.85rem; line-height: 1.4; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = note.content;
        content.textContent = tempDiv.textContent || '';

        noteCard.appendChild(title);
        noteCard.appendChild(content);

        noteCard.addEventListener('click', () => this.expandNote(note.id));
        noteCard.addEventListener('mouseenter', () => {
          noteCard.style.transform = 'translateY(-4px)';
        });
        noteCard.addEventListener('mouseleave', () => {
          noteCard.style.transform = 'translateY(0)';
        });

        stickyContainer.appendChild(noteCard);
      });
    }

    handleSort(sortType: string) {
      let sortedNotes = [...this.notes];
      
      switch (sortType) {
        case 'date':
          sortedNotes.sort((a, b) => b.createdAt - a.createdAt);
          break;
        case 'images':
          sortedNotes = sortedNotes.filter(note => note.content.includes('<img'));
          break;
        case 'text':
          sortedNotes = sortedNotes.filter(note => !note.content.includes('<img'));
          break;
      }

      const stickyContainer = document.getElementById('sticky-notes-container');
      if (!stickyContainer) return;

      stickyContainer.innerHTML = '';
      
      sortedNotes.forEach(note => {
        const noteCard = document.createElement('div');
        noteCard.className = 'sticky-note-card';
        noteCard.dataset.id = note.id;
        noteCard.style.cssText = `
          background-color: ${note.color};
          cursor: pointer;
          width: 200px;
          min-height: 120px;
          padding: 1rem;
          border-radius: 8px;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
          transition: transform 0.2s;
          margin-bottom: 1rem;
        `;

        const title = document.createElement('div');
        title.style.cssText = 'font-weight: 600; color: #333; font-size: 0.95rem; margin-bottom: 0.5rem;';
        title.textContent = note.title + (note.sticky ? ' ðŸ“Œ' : '');

        const content = document.createElement('div');
        content.style.cssText = 'color: #555; font-size: 0.85rem; line-height: 1.4; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical;';
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = note.content;
        content.textContent = tempDiv.textContent || '';

        noteCard.appendChild(title);
        noteCard.appendChild(content);

        noteCard.addEventListener('click', () => this.expandNote(note.id));
        noteCard.addEventListener('mouseenter', () => {
          noteCard.style.transform = 'translateY(-4px)';
        });
        noteCard.addEventListener('mouseleave', () => {
          noteCard.style.transform = 'translateY(0)';
        });

        stickyContainer.appendChild(noteCard);
      });
    }

    escapeHtml(text: string): string {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    renderContent(htmlContent: string): string {
      // Content is already HTML with images, just return it
      return htmlContent;
    }
  }

  class UserPageManager {
    private backgroundOverlay: HTMLElement | null;
    private pageTitle: HTMLElement | null;
    private pageSubtitle: HTMLElement | null;

    constructor() {
      this.backgroundOverlay = document.querySelector('.background-overlay') as HTMLElement;
      this.pageTitle = document.getElementById('page-title');
      this.pageSubtitle = document.getElementById('page-subtitle');
      
      this.loadBackground();
      this.loadPageText();
      this.setupPageTextEditing();
    }

    loadBackground() {
      const savedBackground = localStorage.getItem('userPageBackground');
      if (savedBackground && this.backgroundOverlay) {
        this.backgroundOverlay.style.backgroundImage = `url(${savedBackground})`;
        this.backgroundOverlay.style.opacity = '1';
      }
    }

    loadPageText() {
      const savedTitle = localStorage.getItem('userPageTitle');
      const savedSubtitle = localStorage.getItem('userPageSubtitle');
      
      if (savedTitle !== null && this.pageTitle) {
        this.pageTitle.textContent = savedTitle;
        if (savedTitle === '') {
          this.pageTitle.classList.add('edited-empty');
        }
      }
      
      if (savedSubtitle !== null && this.pageSubtitle) {
        this.pageSubtitle.textContent = savedSubtitle;
        if (savedSubtitle === '') {
          this.pageSubtitle.classList.add('edited-empty');
        }
      }
    }

    setupPageTextEditing() {
      if (this.pageTitle) {
        this.pageTitle.addEventListener('blur', () => {
          const text = this.pageTitle?.textContent?.trim() || '';
          localStorage.setItem('userPageTitle', text);
          if (text === '') {
            this.pageTitle?.classList.add('edited-empty');
          } else {
            this.pageTitle?.classList.remove('edited-empty');
          }
        });
        
        this.pageTitle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.pageTitle?.blur();
          }
        });
      }

      if (this.pageSubtitle) {
        this.pageSubtitle.addEventListener('blur', () => {
          const text = this.pageSubtitle?.textContent?.trim() || '';
          localStorage.setItem('userPageSubtitle', text);
          if (text === '') {
            this.pageSubtitle?.classList.add('edited-empty');
          } else {
            this.pageSubtitle?.classList.remove('edited-empty');
          }
        });
        
        this.pageSubtitle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.pageSubtitle?.blur();
          }
        });
      }
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new UserPageManager();
      new StickyNotesManager();
    });
  } else {
    new UserPageManager();
    new StickyNotesManager();
  }
</script>

<style>
  .user-page {
    min-height: 100vh;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  .background-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0;
    transition: opacity 0.5s ease;
    z-index: 0;
  }

  .background-overlay::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      to bottom,
      rgba(0, 0, 0, 0.3) 0%,
      rgba(0, 0, 0, 0.5) 100%
    );
  }

  .content-wrapper {
    position: relative;
    z-index: 1;
    text-align: center;
    padding: 2rem;
    max-width: 600px;
    width: 100%;
  }

  .page-header {
    position: fixed;
    top: 280px; /* Below sticky notes area (3 rows @ ~140px each + padding) */
    left: 0;
    right: 0;
    text-align: center;
    padding: 2rem;
    z-index: 25;
  }

  @media (max-width: 640px) {
    .page-header {
      top: 200px; /* Below sticky notes area (2 rows on mobile) */
    }
  }

  .page-header h1 {
    font-size: 3rem;
    font-weight: bold;
    margin-bottom: 0.5rem;
    color: #ffffff;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8), 0 0 20px rgba(0, 0, 0, 0.6);
    outline: none;
    cursor: text;
    display: block;
    min-width: 100px;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    transition: background 0.2s;
  }

  .page-header h1:hover,
  .page-header h1:focus {
    background: rgba(255, 255, 255, 0.1);
  }

  .page-header h1:empty:before {
    content: 'My Page';
    color: rgba(255, 255, 255, 0.5);
  }

  .page-header h1.edited-empty:before {
    content: '';
  }

  .welcome-section {
    margin-bottom: 2rem;
  }

  .welcome-section h1 {
    font-size: 3rem;
    font-weight: bold;
    margin-bottom: 0.5rem;
    color: var(--theme-text);
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
  }

  .subtitle {
    font-size: 1.25rem;
    opacity: 0.9;
    color: #ffffff;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8), 0 0 20px rgba(0, 0, 0, 0.6);
    outline: none;
    cursor: text;
    display: block;
    min-width: 150px;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    transition: background 0.2s;
  }

  .subtitle:hover,
  .subtitle:focus {
    background: rgba(255, 255, 255, 0.1);
  }

  .subtitle:empty:before {
    content: 'Your personal workspace';
    color: rgba(255, 255, 255, 0.5);
  }

  .subtitle.edited-empty:before {
    content: '';
  }

  /* Notes Sidebar */
  .notes-sidebar {
    position: fixed;
    right: 0;
    top: 120px;
    bottom: 120px;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 1rem 0 1rem 10px;
    max-height: calc(100vh - 240px);
    overflow-y: auto;
    overflow-x: visible;
    z-index: 150;
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
  }

  .notes-sidebar::-webkit-scrollbar {
    width: 6px;
  }

  .notes-sidebar::-webkit-scrollbar-track {
    background: transparent;
  }

  .notes-sidebar::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 3px;
  }

  .notes-sidebar::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  .collapsed-note-tab {
    max-width: 150px;
    min-width: 100px;
  }

  /* Sticky Notes Container */
  .sticky-notes-container {
    position: fixed;
    top: 2rem;
    left: 2rem;
    z-index: 30;
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    max-width: calc(100vw - 220px);
    overscroll-behavior: contain;
  }

  .sticky-note-card {
    pointer-events: auto !important;
  }

  @media (min-width: 641px) {
    .sticky-notes-container {
      max-height: calc(3 * 140px + 2rem);
      overflow-y: auto;
    }
  }

  @media (max-width: 640px) {
    .sticky-notes-container {
      flex-direction: column !important;
      flex-wrap: nowrap !important;
      top: 4.5rem !important;
      bottom: auto !important;
      height: calc(100vh - 25rem) !important;
      max-height: calc(100vh - 25rem) !important;
      left: 0.5rem !important;
      width: 200px !important;
      max-width: 200px !important;
      overflow-y: scroll !important;
      overflow-x: hidden !important;
      -webkit-overflow-scrolling: touch !important;
      overscroll-behavior: contain !important;
      touch-action: pan-y !important;
    }

    .sticky-note-card {
      flex-shrink: 0 !important;
      touch-action: pan-y !important;
    }
  }

  /* Scrollbar for sticky notes */
  .sticky-notes-container::-webkit-scrollbar {
    width: 4px;
  }

  .sticky-notes-container::-webkit-scrollbar-track {
    background: transparent;
  }

  .sticky-notes-container::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 2px;
  }

  .sticky-notes-container::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  /* Control Bar */
  .control-bar {
    position: fixed;
    top: 1rem;
    right: 1rem;
    z-index: 150;
    display: flex;
    gap: 0.5rem;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(10px);
    padding: 0.5rem;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  .btn-control-bar {
    width: 40px;
    height: 40px;
    border-radius: 8px;
    border: none;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }

  .btn-control-bar:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.05);
  }

  .btn-danger {
    background: rgba(239, 68, 68, 0.6);
  }

  .btn-danger:hover {
    background: rgba(239, 68, 68, 0.8);
  }

  .search-input {
    width: 200px;
    padding: 0.5rem;
    border: none;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.15);
    color: white;
    font-size: 0.9rem;
    outline: none;
  }

  .search-input::placeholder {
    color: rgba(255, 255, 255, 0.6);
  }

  .search-input:focus {
    background: rgba(255, 255, 255, 0.25);
  }

  .sort-select {
    padding: 0.5rem;
    border: none;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.15);
    color: white;
    font-size: 0.9rem;
    cursor: pointer;
    outline: none;
  }

  .sort-select:hover {
    background: rgba(255, 255, 255, 0.25);
  }

  .sort-select option {
    background: #1a1a1a;
    color: white;
  }

  /* View All Panel */
  .view-all-panel {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 300;
    display: flex;
    flex-direction: column;
    padding: 2rem;
    overflow: hidden;
  }

  .view-all-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid rgba(255, 255, 255, 0.2);
  }

  .view-all-header h2 {
    color: white;
    font-size: 1.8rem;
    margin: 0;
  }

  .btn-close-panel {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    background: rgba(239, 68, 68, 0.8);
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }

  .btn-close-panel:hover {
    background: rgba(239, 68, 68, 1);
    transform: scale(1.1);
  }

  .view-all-content {
    flex: 1;
    overflow-y: auto;
    padding-right: 1rem;
  }

  .view-all-content::-webkit-scrollbar {
    width: 8px;
  }

  .view-all-content::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }

  .view-all-content::-webkit-scrollbar-thumb {
    background: rgba(255, 255, 255, 0.3);
    border-radius: 4px;
  }

  .view-all-content::-webkit-scrollbar-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  /* Control Buttons */
  .note-controls {
    position: fixed;
    right: 10px;
    bottom: 124px;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    z-index: 150;
  }

  .btn-control {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
  }

  .btn-add {
    background: rgba(34, 197, 94, 0.8);
    color: white;
  }

  .btn-add:hover {
    background: rgba(34, 197, 94, 1);
    transform: scale(1.1);
  }

  .btn-clear {
    background: rgba(239, 68, 68, 0.8);
    color: white;
  }

  .btn-clear:hover {
    background: rgba(239, 68, 68, 1);
    transform: scale(1.1);
  }

  /* Expanded Notes */
  #notes-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 350;
  }

  #notes-container * {
    box-sizing: border-box;
  }

  .sticky-note-expanded {
    pointer-events: auto;
  }

  @media (max-width: 640px) {
    .page-header {
      top: 200px; /* Below sticky notes area (2 rows on mobile) */
    }

    .page-header h1 {
      font-size: 2rem;
    }

    .subtitle {
      font-size: 1rem;
    }

    .btn-control {
      width: 44px;
      height: 44px;
    }

    .sticky-note-expanded {
      width: 90vw !important;
    }

    .notes-sidebar {
      max-height: 50vh;
    }

    .collapsed-note-tab {
      max-width: 120px;
      font-size: 0.85rem;
    }

    .search-input {
      width: 140px;
      font-size: 0.85rem;
    }

    .sort-select {
      font-size: 0.85rem;
    }

    .btn-control-bar {
      width: 36px;
      height: 36px;
    }
  }
</style>
